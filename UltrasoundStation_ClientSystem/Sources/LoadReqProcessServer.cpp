#include "Headers/LoadReqProcessServer.h"

#include <QList>
#include <QMutex>

//static members
QLoadReqProcServer* QLoadReqProcServer::serverInstance = 0;
QList<QSignRequest*> QLoadReqProcServer::acceptQueue = QList<QSignRequest*>();
QList<QSignRequest*> QLoadReqProcServer::waitProcQueue = QList<QSignRequest*>();
QList<QSignRequest*> QLoadReqProcServer::denyQueue = QList<QSignRequest*>();
QList<QSignRequest*> QLoadReqProcServer::cancelQueue = QList<QSignRequest*>();
QMutex QLoadReqProcServer::mutex ;

QLoadReqProcServer* QLoadReqProcServer::getServerInstance(){
    if( 0 != QLoadReqProcServer::serverInstance ){
        return QLoadReqProcServer::serverInstance;
    }else{
        return new QLoadReqProcServer();
    }
}

bool QLoadReqProcServer::closeServerInstance(void){
    qDebug("QLoadReqProcServer::closeServerInstance(void)");
    //加入销毁服务器的过程
    return true;
}

QLoadReqProcServer::QLoadReqProcServer(){
}
QLoadReqProcServer::~QLoadReqProcServer(){

}
//新的登录请求
bool QLoadReqProcServer::newReq(QSignRequest *req){
    if( 0 == req ){
        qDebug("QLoadReqProcServer::newReq(req):req should not be zero!\n");
        return false;
    }
    mutex.lock();
    QLoadReqProcServer::waitProcQueue.append(req);
    //连接服务器和请求的信号和槽，当等待队列中的元素被处理时，将会通知请求对象
    //connect(QLoadReqProcServer::getServerInstance(),SIGNAL(reqProcessed(QObject*,QSignRequest::REQ_STATUS)),req,SLOT(Req_Processed(QObjcet*,QSignRequest::REQ_STATUS)));
    //记录请求到日志中
    QLoadReqProcServer::recordSignReq(req);
    mutex.unlock();
    return true;
}
//取消登录的请求
bool QLoadReqProcServer::cancelReq( QSignRequest *req){
    if( 0 == req ){
        qDebug("QLoadReqProcServer::cancelReq(req):req should not be zero!\n");
        return false;
    }
    if( true == QLoadReqProcServer::waitProcQueue.contains(req) ){
        QLoadReqProcServer::waitProcQueue.removeOne(req);
        QLoadReqProcServer::cancelQueue.append(req);
    }
    return true;
}
//处理目前队列中的请求
void QLoadReqProcServer::ProcessReq(){
    if(!QLoadReqProcServer::waitProcQueue.isEmpty()){
        qDebug("The Wait Queue is not empty!");
        QSignRequest*lREQ = QLoadReqProcServer::waitProcQueue.first();
        Q_ASSERT_X(lREQ->reqStatus == QSignRequest::REQ_INQUE,"in ProcessReq()","wait queue' item should be REQ_INQUE status");
        if( true == queryReqInfor( lREQ ) ){
            //用户验证为合法用户，触发消息
            //emit serverInstance->reqProcessed((QObject*)waitProcQueue.first(),QSignRequest::REQ_ACCEPT);
            lREQ->reqStatus = QSignRequest::REQ_ACCEPT;
            QLoadReqProcServer::acceptQueue.append(lREQ);//将请求加入到接受队列中
            qDebug("In Server Thread:user sign req accept!");
        }else{//非法用户
            //emit serverInstance->reqProcessed((QObject*)waitProcQueue.first(),QSignRequest::REQ_REJECT);
             lREQ->reqStatus = QSignRequest::REQ_REJECT;
            QLoadReqProcServer::denyQueue.append(lREQ);//将请求加入拒绝队列
            qDebug("user sign req reject!");
            }
        QLoadReqProcServer::waitProcQueue.removeFirst();
        qDebug("wait queue is not empty!");
    }
}
//查询请求是否能够被允许，是否合法
bool QLoadReqProcServer::queryReqInfor( QSignRequest* req){
    if( 0 == req){
        return false;
    }
    //加入验证代码:可以是使用简单文本存储的用户信息验证，也可以是数据库存储的用户信息验证
    return false;
}
//记录目前在服务器上的账号信息
void QLoadReqProcServer::recordSignReq( QSignRequest* req){
    qDebug("recordSignReq() not implement in curQ_ASSERT(false);rent!\n");
}
//void QLoadReqProcServer::reqProcessed(QSignRequest::REQ_STATUS procResult){
//    qDebug("QLoadReqProcServer::reqProcessed");
//}
//为了测试目的
void QLoadReqProcServer::checkQueue(){
    //按照设计意图，显然我们的每一个队列中的元素应该具有相同的特征
    //例如:在waitProcQueue中的请求的状态都应该是REQ_INQUE
    //1.检查waitProcQueue
    QList<QSignRequest* >::iterator itor;
    for(itor = waitProcQueue.begin();itor != waitProcQueue.end();itor++){
        if((*itor)->ProcessSignReq() != QSignRequest::REQ_INQUE){
            Q_ASSERT_X(false,"in checkQueue","while check waitProcQueue");
        }
    }
}
//用户查询REQ状态的接口
QSignRequest::REQ_STATUS QLoadReqProcServer::queryREQStatus(QSignRequest* req){
    if( 0 == req ){
        qDebug("queryREQStatus param should not be zero!\n");
        return QSignRequest::REQ_REJECT;
    }
    QSignRequest::REQ_STATUS s;
    mutex.lock();
    if( waitProcQueue.indexOf(req) != -1){
        s = QSignRequest::REQ_INQUE;
    }
    if( acceptQueue.indexOf(req) != -1){
        s = QSignRequest::REQ_ACCEPT;
    }
    if( acceptQueue.indexOf(req) != -1){
        s = QSignRequest::REQ_REJECT;
    }
    mutex.unlock();
    return s;
}
//线程函数
void QLoadReqProcServer::run(){
    while(1){
        mutex.lock();
        ProcessReq();
        mutex.unlock();
    }
    qDebug("thread will end!");
    exec();
}

